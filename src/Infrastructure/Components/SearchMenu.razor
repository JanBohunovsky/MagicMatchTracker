@inject ILogger<SearchMenu<TItem>> Logger
@using MagicMatchTracker.Infrastructure.Services
@typeparam TItem where TItem : class

<div class="dropdown-menu shadow">
	<AutoFocus class="search-term-container">
		<button class="btn btn-ghost-secondary btn-square" @onclick="@(() => CloseAsync(null))">
			<span class="icon">arrow_back</span>
		</button>
		<input type="text" onfocus="this.select();"
		       @bind="_searchTerm" @bind:after="SearchAsync" @bind:event="oninput"
		       @onkeydown="OnSearchKeyPress"
		       class="form-control search-term" placeholder="@Placeholder"
		       spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" autofocus/>
	</AutoFocus>
	<hr class="dropdown-divider"/>
	@if (_result is null)
	{
		<div class="center m-4">
			<span class="spinner-border text-primary"></span>
		</div>
	}
	else
	{
		if (Provider.Filters.Count > 0)
		{
			<InputRadioGroup @bind-Value="_selectedFilterName" @bind-Value:after="SearchAsync">
				<div class="filters d-flex gap-2 p-2 overflow-x-auto flex-shrink-0">
					@foreach (var filter in Provider.Filters)
					{
						<div>
							<InputRadio class="btn-check btn-sm" Value="filter.Name" id="@filter.Name"/>
							<label class="btn btn-sm btn-outline-secondary" for="@filter.Name">
								@if (_selectedFilterName == filter.Name)
								{
									<span class="icon">check</span>
								}
								<span>@filter.Name</span>
							</label>
						</div>
					}
				</div>
			</InputRadioGroup>
		}

		<ul class="search-results">
			@if (_result.Count == 0)
			{
				<li>
					<span class="dropdown-item-text">@NotFoundMessage</span>
				</li>
			}
			else
			{
				@foreach (var (index, item) in _result.Index())
				{
					<li>
						<button class="dropdown-item @(_selectedIndex == index ? "active" : null)" @onclick="@(() => CloseAsync(item))">
							@ResultItemTemplate(item)
						</button>
					</li>
				}
			}
		</ul>
	}
</div>

@code {

	private IReadOnlyList<TItem>? _result;
	private int _selectedIndex;
	private string? _selectedFilterName;
	private string _searchTerm = string.Empty;
	private CancellationTokenSource? _searchCancellationSource;

	[Parameter, EditorRequired]
    public required ISearchProvider<TItem> Provider { get; set; }

	[Parameter, EditorRequired]
    public required RenderFragment<TItem> ResultItemTemplate { get; set; }

	[Parameter]
	public string Placeholder { get; set; } = "Search";

	[Parameter]
	public string NotFoundMessage { get; set; } = "No results found";

	[Parameter]
    public EventCallback<TItem> OnSelect { get; set; }

	[Parameter]
    public EventCallback OnClose { get; set; }

	protected override async Task OnInitializedAsync()
	{
		_selectedFilterName = Provider.Filters
			.FirstOrDefault(f => f.IsDefault)
			?.Name;
		await SearchAsync();
	}

	private async Task OnSearchKeyPress(KeyboardEventArgs args)
	{
		if (_result is null || _result.Count == 0)
			return;

		switch (args.Key)
		{
			case "Enter" or "Accept":
				await CloseAsync(_result[_selectedIndex]);
				return;

			case "Escape":
				await CloseAsync(null);
				return;

			case "ArrowDown":
				if (_selectedIndex == _result.Count - 1)
					return;

				_selectedIndex++;
				StateHasChanged();
				return;

			case "ArrowUp":
				if (_selectedIndex == 0)
					return;

				_selectedIndex--;
				StateHasChanged();
				return;
		}
	}

	private async Task SearchAsync()
	{
		if (_searchCancellationSource is not null)
			await _searchCancellationSource.CancelAsync();

		_searchCancellationSource = new CancellationTokenSource();
		var cancellationToken = _searchCancellationSource.Token;

		_result = null;
		_selectedIndex = 0;
		StateHasChanged();

		Logger.LogInformation("Searching - Term: \"{SearchTerm}\"; Filter: {Filter}", _searchTerm, _selectedFilterName);
		var selectedFilter = Provider.Filters.FirstOrDefault(f => f.Name == _selectedFilterName);
		_result = await Provider.SearchAsync(_searchTerm, selectedFilter, cancellationToken);

		_searchCancellationSource = null;
		StateHasChanged();
	}

	private async Task CloseAsync(TItem? item)
	{
		if (_searchCancellationSource is not null)
			await _searchCancellationSource.CancelAsync();

		if (item is not null && OnSelect.HasDelegate)
			await OnSelect.InvokeAsync(item);

		if (OnClose.HasDelegate)
			await OnClose.InvokeAsync();
	}

}