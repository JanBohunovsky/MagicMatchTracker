@page "/matches/{id:guid}"
@using MagicMatchTracker.Features.Matches.Components
@using MagicMatchTracker.Features.Matches.Dialogs.DeckSelect
@using MagicMatchTracker.Features.Matches.Dialogs.DetailsEdit
@using MagicMatchTracker.Features.Matches.Dialogs.EndTransition
@using MagicMatchTracker.Features.Matches.Dialogs.ParticipationDetailsEdit
@using MagicMatchTracker.Features.Matches.Dialogs.ParticipationEndStateEdit
@using MagicMatchTracker.Features.Matches.Dialogs.PlayersEdit
@using MagicMatchTracker.Features.Matches.Dialogs.StartTransition
@using MagicMatchTracker.Infrastructure.Pages
@inherits StatefulComponentBase<MatchDetailState>

<PageTitle>@PageTitle - Match Tracker</PageTitle>

@if (State.IsLoading)
{
	<PageLoading/>
	return;
}

@if (State.Match is null)
{
	<NotFound/>
	return;
}

@if (State.Match.HasEnded)
{
	<button class="btn btn-primary btn-fab"
	        @onclick="@(() => State.PlayAgainAsync(CancellationToken))"
	        disabled="@State.IsBusy">
		@if (State.IsBusy)
		{
			<span class="spinner-border spinner-border-sm m-1" aria-hidden="true"></span>
		}
		else
		{
			<span class="icon filled">swords</span>
		}
		<span>Play again</span>
	</button>
}

<div class="heading">
	<h1>@State.Match.GetTitle(includeDate: false)</h1>

	<div class="match-toolbar">
		@if (State.Match.Participations.Count == 0)
		{
			<button class="btn btn-ghost-danger btn-square hover-icon-filled"
			        title="Delete match"
			        @onclick="@(() => State.DeleteMatchAsync(CancellationToken))"
			        disabled="@State.IsBusy">
				<span class="icon" aria-hidden="true">delete</span>
			</button>
		}

		<div class="d-flex flex-row gap-2">
			<button class="btn btn-ghost-secondary btn-square"
			        title="Previous match"
			        @onclick="State.GoToPreviousMatch"
			        disabled="@(State.IsBusy || !State.HasPreviousMatch)">
				<span class="icon" aria-hidden="true">chevron_backward</span>
			</button>

			<button class="btn btn-ghost-secondary btn-square"
			        title="Next match"
			        @onclick="State.GoToNextMatch"
			        disabled="@(State.IsBusy || !State.HasNextMatch)">
				<span class="icon" aria-hidden="true">chevron_forward</span>
			</button>
		</div>

		<button class="btn btn-ghost-secondary btn-square hover-icon-filled"
		        title="Edit match"
		        @onclick="@(() => State.EditMatchAsync(CancellationToken))"
		        disabled="@State.IsBusy">
			<span class="icon" aria-hidden="true">edit</span>
		</button>
	</div>
</div>

<div class="page-content">
	<div class="match-details">
		<div class="detail-entries">
			<div class="detail-entry">
				<span class="icon">calendar_today</span>
				<span>@State.Match.GetEffectiveDate().ToString("dddd, dd MMMM yyyy")</span>
			</div>

			<MatchDurationDisplay Match="State.Match" class="detail-entry"/>

			@if (State.Match.Notes is not null)
			{
				<div class="detail-entry">
					<span class="icon">sticky_note_2</span>
					<span>@State.Match.Notes</span>
				</div>
			}
			@if (State.ShowErrors)
			{
				@foreach (var error in State.GetErrors())
				{
					<div class="detail-entry text-danger">
						<span class="icon">error</span>
						<span>@error.Message</span>
					</div>
				}
			}
		</div>

		<div class="match-actions">
			@if (!State.Match.HasStarted)
			{
				var hasPlayers = State.Match.Participations.Count > 0;
				var buttonStyle = hasPlayers ? "btn-outline-secondary" : "btn-primary";
				var buttonCaption = hasPlayers ? "Change players" : "Add players";
				var iconFilledStyle = hasPlayers ? string.Empty : "filled";
				@* Player selection button *@
				<button class="btn @buttonStyle hover-icon-filled"
				        @onclick="@(() => State.SelectPlayersAsync(CancellationToken))"
				        disabled="@State.IsBusy">
					<span class="icon @iconFilledStyle">patient_list</span>
					<span>@buttonCaption</span>
				</button>

				@if (hasPlayers)
				{
					@* Start match button *@
					<button class="btn btn-primary"
					        @onclick="@(() => State.StartMatchAsync(CancellationToken))"
					        disabled="@State.IsBusy">
						<span class="icon filled">swords</span>
						<span>Start match</span>
					</button>
				}
			}

			@if (State.Match.IsInProgress && State.Match.Participations.All(mp => mp.EndState is not null))
			{
				@* End match button *@
				<button class="btn btn-primary"
				        @onclick="@(() => State.EndMatchAsync(CancellationToken))"
				        disabled="@State.IsBusy">
					<span class="icon filled">trophy</span>
					<span>End the match</span>
				</button>
			}
		</div>
	</div>

	<div class="match-participations">
		@if (HasParticipationsInProgress)
		{
			<div class="participation-list">
				@foreach (var participation in ParticipationsInProgress)
				{
					<MatchParticipationCard
						Participation="participation"
						HasError="HasParticipationError(participation)"/>
				}
			</div>
		}

		@if (HasParticipationsInProgress && HasParticipationsEnded)
		{
			<hr class="my-1"/>
		}

		@if (HasParticipationsEnded)
		{
			<div class="participation-list">
				@foreach (var participation in ParticipationsEnded)
				{
					<MatchParticipationCard
						Participation="participation"
						HasError="HasParticipationError(participation)"/>
				}
			</div>
		}
	</div>
</div>

<MatchDetailsEditDialog/>
<MatchPlayersEditDialog/>
<MatchDeckSelectDialog/>
<MatchParticipationDetailsEditDialog/>
<MatchParticipationEndStateEditDialog/>
<MatchStartTransitionDialog/>
<MatchEndTransitionDialog/>

@code {

	private Guid _id;

	private string PageTitle => State.Match?.GetTitle() ?? "Match Detail";

	private bool HasParticipationsInProgress => State.Match is not null
		&& State.Match.Participations.Any(mp => mp.EndState is null);

	private bool HasParticipationsEnded => State.Match is not null
		&& State.Match.Participations.Any(mp => mp.EndState is not null);

	private IEnumerable<MatchParticipation> ParticipationsInProgress => State.Match?
		.Participations
		.Where(mp => mp.EndState is null)
		.OrderBy(mp => mp.Player.Name) ?? Enumerable.Empty<MatchParticipation>();

	private IEnumerable<MatchParticipation> ParticipationsEnded => State.Match?
		.Participations
		.Where(mp => mp.EndState is not null)
		.OrderByDescending(mp => mp.EndState!.IsWinner)
		.ThenByDescending(mp => mp.EndState!.Turn)
		.ThenBy(mp => mp.Player.Name) ?? Enumerable.Empty<MatchParticipation>();

	[Parameter, EditorRequired]
	public Guid Id { get; set; }

	protected override async Task OnInitializedAsync()
	{
		_id = Id;
		await State.LoadMatchAsync(Id, CancellationToken);
	}

	protected override async Task OnParametersSetAsync()
	{
		if (_id == Id)
			return;

		_id = Id;
		await State.LoadMatchAsync(Id, CancellationToken);
	}

	private bool HasParticipationError(MatchParticipation participation)
	{
		if (!State.ShowErrors)
			return false;

		return State.GetErrors()
			.Any(e => e.AffectedParticipations.Contains(participation));
	}

}