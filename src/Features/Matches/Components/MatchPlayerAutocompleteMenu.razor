@using Microsoft.EntityFrameworkCore
@inject Database Database

@* TODO: Abstract the common layout and logic into a new component. *@
@* The component should not actually be abstract. We don't want to inherit from it, rather we want to use composition (similar to dialogs). *@
@* The data will be loaded from a provider that will be passed in as a parameter. *@
@* - The provider should support grouping (for decks) and ideally filtering (again for decks, like "All", "Owned", "Borrow", etc) *@
@* - The filters will be provided by the provider and the selected filter will be passed into the search method along the search term. *@
@* Another parameters will be a RenderFragments for the list item and the group header. *@
@* - The context should have the item, the group, and whether it's selected or not. *@
@* - This fragment should be rendered inside the `dropdown-item` button. *@
<div class="dropdown-menu shadow">
	<AutoFocus class="search-term-container">
		<button class="btn btn-ghost-secondary btn-square" @onclick="@(() => CloseAsync(null))">
			<span class="icon">arrow_back</span>
		</button>
		<input type="text" onfocus="this.select();"
		       @bind="_searchTerm" @bind:after="SearchAsync" @bind:event="oninput"
		       @onkeydown="OnSearchKeyPress"
		       class="form-control search-term" placeholder="@(Player?.Name ?? "Select a player")"
		       autocomplete="off" autocorrect="off" spellcheck="false" autofocus/>
	</AutoFocus>
	<hr class="dropdown-divider"/>
	@if (_result is null)
	{
		<div class="center m-4">
			<span class="spinner-border text-primary"></span>
		</div>
	}
	else
	{
		<ul class="search-results">
			@foreach (var (index, player) in _result.Index())
			{
				<li>
					<button class="dropdown-item @(_selectedIndex == index ? "active" : null)" @onclick="@(() => CloseAsync(player))">
						<div class="d-flex gap-1">
							<Avatar Player="@player" Size="20" class="m-0.5"/>
							<span>@player.Name</span>
						</div>
					</button>
				</li>
			}
		</ul>
	}
</div>

@code {

	private string _searchTerm = string.Empty;
	private int _selectedIndex;
	private List<Player>? _result;

	[Parameter, EditorRequired]
	public required Match Match { get; set; }

	[Parameter]
    public Player? Player { get; set; }

	[Parameter, EditorRequired]
    public required Dropdown Dropdown { get; set; }

	[Parameter]
	public EventCallback<Player> OnPlayerSelected { get; set; }

	protected override async Task OnInitializedAsync()
	{
		await SearchAsync();
	}

	private async Task OnSearchKeyPress(KeyboardEventArgs args)
	{
		if (_result is null || _result.Count == 0)
			return;

		switch (args.Key)
		{
			case "Enter" or "Accept":
				await CloseAsync(_result[_selectedIndex]);
				return;

			case "Escape":
				await CloseAsync(null);
				return;

			case "ArrowDown":
				if (_selectedIndex == _result.Count - 1)
					return;

				_selectedIndex++;
				StateHasChanged();
				return;

			case "ArrowUp":
				if (_selectedIndex == 0)
					return;

				_selectedIndex--;
				StateHasChanged();
				return;
		}
	}

	private async Task SearchAsync()
	{
		_result = null;
		_selectedIndex = 0;
		StateHasChanged();

		IQueryable<Player> query = Database.Players.OrderBy(p => p.Name);
		if (_searchTerm.IsNotEmpty())
			query = query.Where(p => p.Name.ToLower().Contains(_searchTerm.ToLower()));

		_result = await query.ToListAsync();
		// Keep the original player selected when there's no search term
		if (_searchTerm.IsEmpty() && Player is not null)
			_selectedIndex = Math.Max(_result.IndexOf(Player), 0);
		StateHasChanged();
	}

	private async Task CloseAsync(Player? player)
	{
		if (player is not null && OnPlayerSelected.HasDelegate)
			await OnPlayerSelected.InvokeAsync(player);

		Dropdown.HideMenu();
	}

}