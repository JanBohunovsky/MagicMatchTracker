@using MagicMatchTracker.Features.Matches.Models
@using MagicMatchTracker.Features.Matches.Services
@inherits StatefulComponentBase<MagicMatchTracker.Features.Matches.Services.MatchDeckSelectionDialogState>
@inject MatchDeckSearchProvider SearchProvider

<FormDialog
	TModel="MatchDeckSelectModel"
	Model="State.Model"
	FullscreenMode="DialogFullscreenMode.Mobile"
	OnDialogShown="OnDialogShown"
	OnDialogHidden="OnDialogHidden"
	OnSubmit="@(() => State.SaveAsync(CancellationToken))">
	<div class="modal-header flex-column align-items-stretch">
		<div class="text-content gap-2">
			<Avatar Player="@context.Player" Size="24"/>
			<h5 class="modal-title">@context.Player.Name.ToPossessive() deck</h5>
			<button type="button" class="btn-close" aria-label="Close" @onclick="State.Cancel" disabled="@State.IsBusy"></button>
		</div>

		<AutoFocus class="mt-3 mb-2">
			<input type="text" onfocus="this.select();" id="search-term"
			       @bind="_searchTerm" @bind:after="SearchAsync" @bind:event="oninput"
			       class="form-control search-term text-truncate"
			       placeholder="Search decks..."
			       spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" autofocus/>
		</AutoFocus>

		<div class="d-flex flex-column">
			<InputRadioGroup @bind-Value="_selectedPlayerId" @bind-Value:after="SearchAsync">
				<div class="d-flex gap-2 overflow-x-auto flex-shrink-0">
					@foreach (var player in _playerFilters)
					{
						<div>
							<InputRadio class="btn-check btn-sm" Value="player.Id" id="@player.Id"/>
							<label class="btn btn-sm btn-outline-secondary" for="@player.Id">
								@if (_selectedPlayerId == player.Id)
								{
									<span class="icon">check</span>
								}
								else if (player.Id != Guid.Empty)
								{
									<Avatar Player="@player" Size="21"/>
								}
								<span>@player.Name</span>
							</label>
						</div>
					}
				</div>
			</InputRadioGroup>
		</div>
	</div>

	<div class="modal-body d-flex flex-column gap-0 p-0">
		@if (_decks is null)
		{
			<div class="center m-4">
				<span class="spinner-border text-primary"></span>
			</div>
		}
		else if (_decks.Count == 0)
		{
			if (_selectedPlayerId != Guid.Empty)
			{
				<span class="center my-5 d-flex flex-column gap-3 align-items-center justify-content-start">
					<span class="icon filled cover-icon text-primary">box_add</span>
					@if (_searchTerm.IsEmpty())
					{
						<span>@SelectedPlayer!.Name has no decks yet</span>
					}
					else
					{
						<span>No decks found</span>
					}
					<button type="button" class="btn btn-primary" @onclick="AddNewDeckAsync">
						<span class="icon">add</span>
						<span>New deck</span>
					</button>
				</span>
			}
			else
			{
				<span class="center m-4">No decks found</span>
			}
		}
		else
		{
			<InputRadioGroup @bind-Value="_selectedDeckId" @bind-Value:after="@(() => context.Deck = _decks.FirstOrDefault(d => d.Id == _selectedDeckId))">
				<div class="list-group list-group-flush">
					@foreach (var deck in _decks)
					{
						var isTaken = context.IsDeckTakenByAnotherPlayer(deck);
						<div class="list-group-item list-group-item-action d-flex align-items-center gap-3 py-0 deck-list-item @(isTaken ? "disabled" : null)"
						     style="--deck-image-url: url('@deck.ImageUri');">
							<InputRadio TValue="Guid?" class="form-check-input m-0" id="@deck.Id" Value="@deck.Id" disabled="@isTaken"/>
							<label class="form-check-label flex-grow-1 d-flex flex-column user-select-none py-2" for="@deck.Id">
								<span class="deck-name">@(deck.Name ?? deck.Commander)</span>
								@if (deck.Name is not null)
								{
									<span class="small text-muted">@deck.Commander</span>
								}
								@if (deck.Partner is not null)
								{
									<span class="small text-muted">@deck.Partner</span>
								}
								@if (_selectedPlayerId == Guid.Empty)
								{
									<span class="small text-content">
										<Avatar Player="deck.Owner" Size="16"/> @deck.Owner.Name
									</span>
								}
							</label>
						</div>
					}
					@if (_selectedPlayerId != Guid.Empty)
					{
						<button type="button" class="list-group-item list-group-item-action text-content gap-2 py-3"
						        @onclick="AddNewDeckAsync">
							<span class="icon text-muted">add</span>
							<span>New deck</span>
						</button>
					}
				</div>
			</InputRadioGroup>
		}
	</div>

	<div class="modal-footer">
		<div class="flex-grow-1">
			<button type="button" class="btn btn-ghost-primary hover-icon-filled"
			        @onclick="EditSelectedDeckAsync"
			        disabled="@(State.IsBusy || !IsSelectedDeckVisible)">
				<span>Edit deck</span>
			</button>
		</div>
		<button type="button" class="btn btn-outline-secondary" @onclick="State.Cancel" disabled="@State.IsBusy">Cancel</button>
		<button type="submit" class="btn btn-primary" disabled="@(State.IsBusy || !IsSelectedDeckVisible)">
			@if (State.IsBusy)
			{
				<span class="spinner-border spinner-border-sm" aria-hidden="true"></span>
			}
			<span>Save</span>
		</button>
	</div>
</FormDialog>

<div class="nested-modal-layer">
	<DeckEditDialog IsFullscreen="false"/>
</div>

@code {

	private CancellationTokenSource? _searchCancellationSource;
	private string _searchTerm = string.Empty;
	private List<Player> _playerFilters = [];
	private Guid _selectedPlayerId;
	private IReadOnlyList<Deck>? _decks;
	private Guid? _selectedDeckId;

	private Player? SelectedPlayer => _selectedPlayerId != Guid.Empty
		? _playerFilters.FirstOrDefault(p => p.Id == _selectedPlayerId)
		: null;

	private bool IsSelectedDeckVisible => _decks is not null && _decks.Any(d => d.Id == _selectedDeckId);

	private async Task SearchAsync()
	{
		// TODO: Implement actual throttling
		if (_searchCancellationSource is not null)
			await _searchCancellationSource.CancelAsync();

		_searchCancellationSource = new CancellationTokenSource();
		var cancellationToken = _searchCancellationSource.Token;

		_decks = null;
		StateHasChanged();

		_decks = await SearchProvider.SearchAsync(_searchTerm, SelectedPlayer, cancellationToken);

		_searchCancellationSource = null;
		StateHasChanged();
	}

	private async Task OnDialogShown(MatchDeckSelectModel editModel)
	{
		_searchTerm = string.Empty;
		_playerFilters = editModel.AvailablePlayers
			.Prepend(new Player { Name = "All" })
			.ToList();

		_selectedPlayerId = editModel.Player.Id;
		_selectedDeckId = editModel.Deck?.Id;
		await SearchAsync();
	}

	private async Task OnDialogHidden()
	{
		_playerFilters = [];
		_selectedPlayerId = Guid.Empty;

		if (_searchCancellationSource is not null)
			await _searchCancellationSource.CancelAsync();
	}

	private async Task AddNewDeckAsync()
	{
		var player = SelectedPlayer;
		if (player is null)
			return;

		var success = await State.AddNewDeckAsync(player, CancellationToken);
		if (success)
			await SearchAsync();
	}

	private async Task EditSelectedDeckAsync()
	{
		if (_selectedDeckId is null || _decks is null)
			return;

		var deck = _decks.FirstOrDefault(d => d.Id == _selectedDeckId);
		if (deck is null)
			return;

		var success = await State.EditDeckAsync(deck, CancellationToken);
		if (success)
			await SearchAsync();
	}

}