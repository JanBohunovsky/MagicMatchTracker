@using MagicMatchTracker.Features.Matches.Models
@inherits StatefulComponentBase<MagicMatchTracker.Features.Matches.Services.MatchEventEditDialogState>

<FormDialog
	TModel="MatchEventEditModel"
	Model="State.Model"
	OnSubmit="@(() => State.SaveAsync(CancellationToken))">
	<div class="modal-header">
		<h5 class="modal-title text-content">
			@Title for <Avatar Player="context.Player" Size="24" class="ms-1"/> @context.Player.Name
		</h5>
		<button type="button" class="btn-close" aria-label="Close" @onclick="State.Cancel" disabled="@State.IsBusy"></button>
	</div>
	<div class="modal-body d-flex flex-column gap-3">
		<div>
			<label for="eventType" class="form-label">Event type</label>
			<InputSelectCustom id="eventType" disabled="@State.IsBusy"
			                   @bind-Value="context.Type"
			                   AllowEmptyValue="false"
			                   ValuesProvider="GetEventTypeValues">
				<ItemTemplate Context="eventType">
					<span class="icon">@GetEventTypeIcon(eventType)</span>
					<span>@eventType.GetDisplayName()</span>
				</ItemTemplate>
			</InputSelectCustom>
		</div>

		<div>
			<label for="turn" class="form-label">Turn</label>
			<InputNumber @bind-Value="context.Turn" class="form-control" id="turn" autofocus
			             min="1" max="99"
			             disabled="@State.IsBusy"/>
			<ValidationMessage For="() => context.Turn" class="invalid-feedback"/>
		</div>

		@if (context.Type is MatchEventType.PlayerLost)
		{
			<div>
				<label for="killer" class="form-label">Killer</label>
				<InputSelectCustom id="killer" disabled="@State.IsBusy"
				                   @bind-Value="context.Killer"
				                   EmptyValueText="Select a player..."
				                   ValuesProvider="() => context.PlayersInMatch.OrderBy(p => p.Name)">
					<ItemTemplate Context="player">
						<Avatar Player="player" Size="24"/>
						<span>@player.Name</span>
					</ItemTemplate>
				</InputSelectCustom>
				<ValidationMessage For="() => context.Killer" class="invalid-feedback"/>
			</div>
		}

		@if (context.Type is MatchEventType.PlayerWon && context.CanKillRemainingPlayers)
		{
			<div class="form-check">
				<InputCheckbox @bind-Value="context.KillRemainingPlayers" class="form-check-input" id="killRemainingPlayers"
				               disabled="@State.IsBusy"/>
				<label class="form-check-label text-content column-gap-2 flex-wrap" for="killRemainingPlayers">
					<span>Kill remaining players</span>
					<div class="d-flex align-items-center small text-muted">
						<span>(</span>
						@{ var started = false; }
						@foreach (var player in context.PlayersToKill.OrderBy(p => p.Name))
						{
							@if (started)
							{
								<span class="me-1">,</span>
							}
							else
							{
								started = true;
							}

							<div class="text-content">
								<Avatar Player="player" Size="18"/>
								<span>@player.Name</span>
							</div>
						}
						<span>)</span>
					</div>
				</label>
			</div>
		}

		@if (context.Type is MatchEventType.PlayerLost || context.KillRemainingPlayers)
		{
			<div>
				<label for="loseCondition" class="form-label">Lose condition</label>
				@* TODO: Is there a way to make this work nicely with nullable structs? *@
				<InputSelectCustom id="loseCondition" disabled="@State.IsBusy"
				                   TValue="LoseCondition?"
				                   @bind-Value="context.LoseCondition"
				                   EmptyValueText="Select a lose condition..."
				                   ValuesProvider="GetLoseConditionValues">
					<ItemTemplate Context="loseCondition">
						<div class="text-content gap-2">
							<span class="icon">@GetLoseConditionIcon(loseCondition!.Value)</span>
							<div class="d-flex flex-column">
								<span>@loseCondition.Value.GetDisplayName()</span>
								<span class="small opacity-75 text-wrap">@loseCondition.Value.GetDescription()</span>
							</div>
						</div>
					</ItemTemplate>
				</InputSelectCustom>
				<ValidationMessage For="() => context.LoseCondition" class="invalid-feedback"/>
			</div>
		}

		<div>
			<label for="notes" class="form-label">Notes</label>
			<InputTextArea @bind-Value="context.Notes" class="form-control" id="notes"
			               rows="3"
			               disabled="@State.IsBusy"/>
		</div>

		<details>
			<summary class="user-select-none">Advanced</summary>
			<div class="d-flex flex-column gap-3 mt-2">
				<div>
					<label for="time" class="form-label">Time</label>
					<InputDate @bind-Value="context.Time" class="form-control" id="time"
					           Type="InputDateType.DateTimeLocal" step="1"
					           disabled="@State.IsBusy" />
					@if (State.IsNew)
					{
						<span class="small text-muted">Leave empty to use current time upon saving.</span>
					}
				</div>
			</div>
		</details>
	</div>
	<div class="modal-footer">
		<button type="button" class="btn btn-outline-secondary" @onclick="State.Cancel" disabled="@State.IsBusy">Cancel</button>
		<button type="submit" class="btn btn-primary" disabled="@(State.IsBusy)">
			@if (State.IsBusy)
			{
				<span class="spinner-border spinner-border-sm" aria-hidden="true"></span>
			}
			<span>Save</span>
		</button>
	</div>
</FormDialog>

@code {

	private string Title => State.IsNew ? "New event" : "Edit event";

	private string? GetEventTypeIcon(MatchEventType eventType) => eventType switch
	{
		MatchEventType.PlayerLost => "skull",
		MatchEventType.PlayerWon => "trophy",
		_ => null,
	};

	private string? GetLoseConditionIcon(LoseCondition loseCondition) => loseCondition switch
	{
		LoseCondition.CombatDamage => "swords",
		LoseCondition.LifeLoss => "mode_heat",
		LoseCondition.CommanderDamage => "crown",
		LoseCondition.DeckedOut => "cyclone",
		LoseCondition.Poison => "water_drop",
		LoseCondition.WinEffect => "star_shine",
		LoseCondition.LoseEffect => "skull",
		LoseCondition.Concede => "door_back",
		LoseCondition.Other => "sticky_note_2",
		_ => null,
	};

	private IEnumerable<MatchEventType> GetEventTypeValues()
	{
		yield return MatchEventType.PlayerLost;
		yield return MatchEventType.PlayerWon;
	}

	private IEnumerable<LoseCondition?> GetLoseConditionValues()
	{
		return Enum.GetValues<LoseCondition>()
			.Select(lc => (LoseCondition?)lc);
	}

}