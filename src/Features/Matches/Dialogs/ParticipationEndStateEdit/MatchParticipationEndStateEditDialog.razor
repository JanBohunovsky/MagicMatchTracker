@using MagicMatchTracker.Infrastructure.Dialogs
@inherits StatefulComponentBase<MatchParticipationEndStateEditDialogState>

<FormDialog
	TModel="MatchParticipationEndStateEditModel"
	Model="State.Model"
	OnSubmit="@(() => State.SaveAsync(CancellationToken))">
	<div class="modal-header">
		<h5 class="modal-title text-content">
			@Title for <Avatar Player="context.Player" Size="24" class="ms-1"/> @context.Player.Name
		</h5>
		<button type="button" class="btn-close" aria-label="Close" @onclick="State.Cancel" disabled="@State.IsBusy"></button>
	</div>
	<div class="modal-body d-flex flex-column gap-3">
		@* End state *@
		<div>
			<label for="endState" class="form-label">End state</label>
			<InputSelectCustom id="endState" disabled="@(State.IsBusy || context.HasMatchEnded)"
			                   @bind-Value="context.IsWinner"
			                   AllowEmptyValue="false"
			                   ValuesProvider="GetEndStateValues">
				<ItemTemplate Context="isWinner">
					@if (isWinner)
					{
						<span class="icon">trophy</span>
						<span>Player won</span>
					}
					else
					{
						<span class="icon">skull</span>
						<span>Player lost</span>
					}
				</ItemTemplate>
			</InputSelectCustom>
		</div>

		@* Turn *@
		<div>
			<label for="turn" class="form-label">Turn</label>
			<InputNumber @bind-Value="context.Turn" class="form-control" id="turn" autofocus
			             min="1" max="99"
			             disabled="@State.IsBusy"/>
			<ValidationMessage For="() => context.Turn" class="invalid-feedback"/>
		</div>

		@* Kill Remaining Players (Winner only) *@
		@if (context.IsWinner && context.CanKillRemainingPlayers)
		{
			<div class="form-check">
				<InputCheckbox @bind-Value="context.KillRemainingPlayers" class="form-check-input" id="killRemainingPlayers"
				               disabled="@State.IsBusy"/>
				<label class="form-check-label text-content column-gap-2 flex-wrap" for="killRemainingPlayers">
					<span>Kill remaining players</span>
					<div class="d-flex align-items-center small text-muted">
						<span>(</span>
						@{ var started = false; }
						@foreach (var player in context.PlayersToKill.OrderBy(p => p.Name))
						{
							@if (started)
							{
								<span class="me-1">,</span>
							}
							else
							{
								started = true;
							}

							<div class="text-content">
								<Avatar Player="player" Size="18"/>
								<span>@player.Name</span>
							</div>
						}
						<span>)</span>
					</div>
				</label>
			</div>
		}

		@* Lose Condition *@
		@if (!context.IsWinner || context.KillRemainingPlayers)
		{
			<div>
				<label for="loseCondition" class="form-label">Lose condition</label>
				@* TODO: Is there a way to make this work nicely with nullable structs? *@
				<InputSelectCustom id="loseCondition" disabled="@State.IsBusy"
				                   TValue="LoseCondition?"
				                   @bind-Value="context.LoseCondition"
				                   EmptyValueText="Select a lose condition..."
				                   ValuesProvider="GetLoseConditionValues">
					<ItemTemplate Context="loseCondition">
						<div class="text-content gap-2">
							<LoseConditionIcon Value="loseCondition!.Value"/>
							<div class="d-flex flex-column">
								<span>@loseCondition.Value.DisplayName</span>
								<span class="small opacity-75 text-wrap">@loseCondition.Value.Description</span>
							</div>
						</div>
					</ItemTemplate>
				</InputSelectCustom>
				<ValidationMessage For="() => context.LoseCondition" class="invalid-feedback"/>
			</div>
		}

		@* Killer (Lose only) *@
		@if (!context.IsWinner && context.LoseCondition?.HasKiller is true)
		{
			<div>
				<label for="killer" class="form-label">Killer</label>
				<InputSelectCustom id="killer" disabled="@State.IsBusy"
				                   @bind-Value="context.Killer"
				                   EmptyValueText="Select a player..."
				                   ValuesProvider="() => context.PlayersInMatch.OrderBy(p => p.Name)">
					<ItemTemplate Context="player">
						<Avatar Player="player" Size="24"/>
						<span>@player!.Name</span>
					</ItemTemplate>
				</InputSelectCustom>
				<ValidationMessage For="() => context.Killer" class="invalid-feedback"/>
			</div>
		}

		<div>
			<label for="notes" class="form-label">Notes</label>
			<InputTextArea @bind-Value="context.Notes" class="form-control" id="notes"
			               rows="3"
			               disabled="@State.IsBusy"/>
		</div>

		@* Advanced *@
		@if (context.IsLive)
		{
			<details>
				<summary class="user-select-none">Advanced</summary>
				<div class="d-flex flex-column gap-3 mt-2">
					<div>
						<label for="time" class="form-label">Time</label>
						<InputDate @bind-Value="context.Time" class="form-control" id="time"
						           Type="InputDateType.DateTimeLocal" step="1"
						           disabled="@State.IsBusy"/>
						@if (State.IsNew)
						{
							<span class="small text-muted">Leave empty to use current time upon saving.</span>
						}
					</div>
				</div>
			</details>
		}
	</div>
	<div class="modal-footer">
		<button type="button" class="btn btn-outline-secondary" @onclick="State.Cancel" disabled="@State.IsBusy">Cancel</button>
		<button type="submit" class="btn btn-primary" disabled="@(State.IsBusy)">
			@if (State.IsBusy)
			{
				<span class="spinner-border spinner-border-sm" aria-hidden="true"></span>
			}
			<span>Save</span>
		</button>
	</div>
</FormDialog>

@code {

	private string Title => State.IsNew ? "Set end state" : "Edit end state";

	private IEnumerable<bool> GetEndStateValues()
	{
		yield return false;
		yield return true;
	}

	private IEnumerable<LoseCondition?> GetLoseConditionValues()
	{
		return Enum.GetValues<LoseCondition>()
			.Select(lc => (LoseCondition?)lc);
	}

}