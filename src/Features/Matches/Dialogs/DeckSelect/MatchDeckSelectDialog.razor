@using System.Reactive.Disposables
@using System.Reactive.Disposables.Fluent
@using System.Reactive.Linq
@using MagicMatchTracker.Features.Shared.Dialogs.DeckEdit
@using MagicMatchTracker.Infrastructure.Dialogs
@using MagicMatchTracker.Infrastructure.Reactive
@using Microsoft.EntityFrameworkCore
@inherits StatefulComponentBase<MatchDeckSelectionDialogState>
@inject Database Database

<FormDialog
	TModel="MatchDeckSelectModel"
	Model="State.Model"
	FullscreenMode="DialogFullscreenMode.Mobile"
	OnDialogShown="OnDialogShown"
	OnDialogHidden="OnDialogHidden"
	OnSubmit="@(() => State.SaveAsync(CancellationToken))">
	<div class="modal-header flex-column align-items-stretch">
		<div class="text-content gap-2">
			<Avatar Player="@context.Player" Size="24"/>
			<h5 class="modal-title">@context.Player.Name.ToPossessive() deck</h5>
			<button type="button" class="btn-close" aria-label="Close" @onclick="State.Cancel" disabled="@State.IsBusy"></button>
		</div>

		<AutoFocus class="mt-3 mb-2">
			<input type="text" onfocus="this.select();" id="search-term"
			       @bind="_searchTerm.Value"  @bind:event="oninput"
			       class="form-control search-term text-truncate"
			       placeholder="Search decks..."
			       spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" autofocus/>
		</AutoFocus>

		<div class="d-flex flex-column">
			<InputRadioGroup @bind-Value="_selectedPlayerId.Value">
				<div class="d-flex gap-2 overflow-x-auto flex-shrink-0">
					@foreach (var player in _playerFilters)
					{
						<div>
							<InputRadio class="btn-check btn-sm" Value="player.Id" id="@player.Id"/>
							<label class="btn btn-sm btn-outline-secondary" for="@player.Id">
								@if (_selectedPlayer.Value == player)
								{
									<span class="icon">check</span>
								}
								else if (player.Id != Guid.Empty)
								{
									<Avatar Player="@player" Size="21"/>
								}
								<span>@player.Name</span>
							</label>
						</div>
					}
				</div>
			</InputRadioGroup>
		</div>
	</div>

	<div class="modal-body d-flex flex-column gap-0 p-0">
		@if (!_decks.HasSource)
		{
			<div class="center m-4">
				<span class="spinner-border text-primary"></span>
			</div>
		}
		else if (_decks.Count == 0)
		{
			if (_selectedPlayer.Value is not null)
			{
				<span class="center my-5 d-flex flex-column gap-3 align-items-center justify-content-start">
					<span class="icon filled huge text-primary">box_add</span>
					@if (_searchTerm.Value.IsEmpty())
					{
						<span>@_selectedPlayer.Value.Name has no decks yet</span>
					}
					else
					{
						<span>No decks found</span>
					}
					<button type="button" class="btn btn-primary" @onclick="AddNewDeckAsync">
						<span class="icon">add</span>
						<span>New deck</span>
					</button>
				</span>
			}
			else
			{
				<span class="center m-4">No decks found</span>
			}
		}
		else
		{
			<InputRadioGroup @bind-Value="_selectedDeckId" @bind-Value:after="@(() => context.Deck = _decks.FirstOrDefault(d => d.Id == _selectedDeckId))">
				<div class="list-group list-group-flush">
					@foreach (var deck in _decks)
					{
						var isTaken = context.IsDeckTakenByAnotherPlayer(deck);
						<div class="list-group-item list-group-item-action list-group-item-deck-background d-flex align-items-center gap-3 py-0 deck-list-item @(isTaken ? "disabled" : null)"
						     style="--deck-image-url: url('@deck.ImageUri');">
							<InputRadio TValue="Guid?" class="form-check-input m-0" id="@deck.Id" Value="@deck.Id" disabled="@isTaken"/>
							<label class="form-check-label flex-grow-1 d-flex flex-column user-select-none py-2" for="@deck.Id">
								<span class="deck-name">@(deck.Name ?? deck.Commander)</span>
								@if (deck.Name is not null)
								{
									<span class="small text-muted">@deck.Commander</span>
								}
								@if (deck.Partner is not null)
								{
									<span class="small text-muted">@deck.Partner</span>
								}
								@if (_selectedPlayer.Value is null)
								{
									<div class="small text-content">
										<Avatar Player="deck.Owner" Size="16"/>
										<span>@deck.Owner.Name</span>
										@if (deck.Owner.Alias is not null)
										{
											<span class="text-muted small ms-0.5">@deck.Owner.Alias</span>
										}
									</div>
								}
							</label>
						</div>
					}
					@if (_selectedPlayer.Value != null)
					{
						<button type="button" class="list-group-item list-group-item-action text-content gap-2 py-3"
						        @onclick="AddNewDeckAsync">
							<span class="icon text-muted">add</span>
							<span>New deck</span>
						</button>
					}
				</div>
			</InputRadioGroup>
		}
	</div>

	<div class="modal-footer">
		<div class="flex-grow-1">
			<button type="button" class="btn btn-ghost-primary hover-icon-filled"
			        @onclick="EditSelectedDeckAsync"
			        disabled="@(State.IsBusy || !IsSelectedDeckVisible)">
				<span>Edit deck</span>
			</button>
		</div>
		<button type="button" class="btn btn-outline-secondary" @onclick="State.Cancel" disabled="@State.IsBusy">Cancel</button>
		<button type="submit" class="btn btn-primary" disabled="@(State.IsBusy || !IsSelectedDeckVisible)">
			@if (State.IsBusy)
			{
				<span class="spinner-border spinner-border-sm" aria-hidden="true"></span>
			}
			<span>Save</span>
		</button>
	</div>
</FormDialog>

<div class="nested-modal-layer">
	<DeckEditDialog IsFullscreen="false"/>
</div>

@code {

	private CompositeDisposable _disposables = new();
	private ReactiveProperty<string> _searchTerm = new(string.Empty);
	private ReactiveProperty<Guid> _selectedPlayerId = new(Guid.Empty);
	private ReactiveReadOnlyProperty<Player?> _selectedPlayer = null!;

	private List<Player> _playerFilters = [];
	private SearchableDecks _decks = null!;
	private Guid? _selectedDeckId;

	private bool IsSelectedDeckVisible => _decks.Any(d => d.Id == _selectedDeckId);

	protected override void OnInitialized()
	{
		base.OnInitialized();
		_decks = new SearchableDecks(StateHasChanged);

		// TODO: I've tried to move it here, because technically there's no reason to NOT have it here,
		//  but it has some issues:
		//   - Closing the dialog doesn't cancel any loading (e.g. LoadDecksAsync)
		//   - ReactiveReadOnlyProperty subscription can't have DistinctUntilChanged,
		//     otherwise re-opening the same user will result in an infinite "loading".

		_selectedPlayer = _selectedPlayerId
			.Select(id => id != Guid.Empty ? _playerFilters.FirstOrDefault(p => p.Id == id) : null)
			.ToProperty();

		_searchTerm.Select(s => s.Trim())
			.Select(s => s.IsEmpty() ? Observable.Return(s) : Observable.Return(s).Delay(TimeSpan.FromMilliseconds(500)))
			.Switch()
			.DistinctUntilChanged()
			.ObserveOn(SynchronizationContext.Current!)
			.Subscribe(s => _decks.UpdateSearchTerm(s))
			.DisposeWith(_disposables);

		_selectedPlayer.Do(_ => _decks.UpdateSource(null))
			.SelectLatestAsync(LoadDecksAsync)
			.ObserveOn(SynchronizationContext.Current!)
			.Subscribe(d => _decks.UpdateSource(d))
			.DisposeWith(_disposables);
	}

	private async Task OnDialogShown(MatchDeckSelectModel editModel)
	{
		// _disposables = new CompositeDisposable();
		// _searchTerm = new ReactiveProperty<string>(string.Empty);
		// _selectedPlayerId = new ReactiveProperty<Guid>(editModel.Player.Id);
		// _decks = new SearchableDecks(StateHasChanged);

		_decks.Reset();
		_playerFilters = editModel.AvailablePlayers
			.Prepend(new Player { Name = "All" })
			.ToList();

		_searchTerm.Value = string.Empty;
		_selectedPlayerId.Value = editModel.Player.Id;
		_selectedDeckId = editModel.Deck?.Id;
	}

	private async Task OnDialogHidden()
	{
		// _disposables.Dispose();
		// _selectedPlayer.Dispose();
		// _selectedPlayerId.Dispose();
		// _searchTerm.Dispose();

		_playerFilters = [];
	}

	private async Task<IReadOnlyList<Deck>> LoadDecksAsync(Player? player, CancellationToken cancellationToken)
	{
		await Task.Delay(2000, cancellationToken);
		var query = Database.Decks.Where(d => !d.IsArchived);

		if (player is not null)
		{
			query = query.Where(d => d.Owner == player);
		}

		return await query.ToListAsync(cancellationToken);
	}

	private async Task AddNewDeckAsync()
	{
		var player = _selectedPlayer.Value;
		if (player is null)
			return;

		var success = await State.AddNewDeckAsync(player, CancellationToken);
		if (success)
			_selectedPlayer.NotifyPropertyChanged();
	}

	private async Task EditSelectedDeckAsync()
	{
		if (_selectedDeckId is null)
			return;

		var deck = _decks.FirstOrDefault(d => d.Id == _selectedDeckId);
		if (deck is null)
			return;

		var success = await State.EditDeckAsync(deck, CancellationToken);
		if (success)
			_selectedPlayer.NotifyPropertyChanged();
	}

	protected override void DisposeCore()
	{
		base.DisposeCore();
		_disposables.Dispose();
	}
}